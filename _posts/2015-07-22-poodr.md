---
layout: post
title: What I Learned from Poodr - The Concise Recap
---

# -- IN PROGRESS --

I'll keep this concise, in the spirit of [less is more](http://confreaks.tv/videos/goruco2011-less-the-path-to-better-design).

Reading POODR has been one of the most beneficial things I've done in my long, illustrious career as a programmer (clocking in at approx [`$("Feb 02 2015").timeago();`](http://timeago.yarp.com/)). It's been recommended to me since ~week 2 of my immersive program at Flatiron School, but I'm glad I put it off until I'd built some un-POODR-like apps of my own. That context helped me draw connections between the abstract principles discussed in the book and very real production code I'm working on now. So without further ado:

## Main takeaways from POODR:

### 1. Think about code in terms of objects and messages, not procedures

As Chapter 2 emphasizes, classes (and methods, really) should have a single responsibility. If you find your class carrying multiple responsibilities, break each one into its own separate class. You should conceptualize a class as an object that passes and receives messages, not something that executes some long procedure. Objects that execute a procedure can find themselves performing multiple responsibilites.

One strong example of this is a Ruby Code Challenge feature I'm currently working on, conveniently written entirely in Javascript. It's basic functionality is as follows:

- challenge has a question, answer, solution, and assertion
- user inputs answer (a string of code, like "my_array = [1,2,3]")
- feature evaluates answer to get its return value
- feature evaluates solution to get its return value
- feature parses answer and solution into a boolean assertion, such as `assert_equal(answer, solution)`
- after evaluating, feature displays feedback to the user:
    - "Correct" if assertion returns true
    - Rspec-esque message if assertion is false (ex. "expect x to equal y")
    - Error message stack trace (abbreviated) if error

Below is the `_evaluateRuby` function. In this iteration, you can see it's violating the single responsibility principle like crazy. It's following a long, procedural chain of events. It's calling external services (the [repl.it js client](https://github.com/replit/ReplitClient.js)). It doesn't give two duck types about POODR.

It is **rigid, immobile, and viscous** - 3 of the 4 bad code qualities codified by [Robert Martin](http://blog.cleancoder.com/). It is not **transparent, reasonable, or exemplary** - positive qualities outlined in POODR (as more or less the inverse of Martin's negative qualities).

```javascript
CodeChallenge.prototype = {
  _evaluateRuby: function(){
    var studentResponse = this.editor.getValue();
    var testingLib = [ "really long string" ];
    var rubyRepl = this.challengeHolder.replItConnection; // establish connection to repl.it client

    return rubyRepl.connect().then(function(){
      return rubyRepl.evaluate( studentResponse, {  // first call to repl.it api
        stdout: function(out){}
      });
    }).then(function(result) {
      if ( result.error.length ){
        this.insertResponseMessage(result.error); // first handoff to error handler
      } else {
        var assertion = this.parseAssertion(result.data);
        rubyRepl.connect().then(function(){
          return rubyRepl.evaluate( testingLib + "\n" + assertion, { // second call to repl.it api
            stdout: function(out){}
          });
        }).then(function(result) {
          if ( result.error.length ) {
            this.insertResponseMessage(result.error); // second handoff to error handler
          } else {
            this.responseHandler(result.data); // handoff to yet another function to display Correct/Incorrect response
          }
        }.bind(this));
      }
    }.bind(this));
  },
  // other functions, etc.
}
```

Applying what I learned from POODR, my first step in refactoring was to pull out each responsibility into its own separate object. `rubyRepl.connect()` and `rubyRepl.evaluate()` were moved into a new `rubyRepl` item that takes care of evaluating whatever code string you pass it. `parseAssertion()` was moved into its own `rubyAssertion` object, which builds a code string (specifically, the assertion code string, which reads something like `assert_equal(studentResponse, solution)`).

Now this function is closer to doing one thing: evaluating a string of Ruby code.

```javascript
CodeChallenge.prototype = {
  _evaluateRuby: function() {
    var rubyRepl = this.challengeHolder.replItConnection; // establish connection to repl.it client
    var studentResponse = this.editor.getValue();

    return W(rubyRepl.evaluate( // first and only call to repl.it api
      new RubyReplAssertion({   // new RubyAssertion object
        response: studentResponse,
        validation: this.validation
      })))
      .with(this)
      .timeout(4000)
      .then(function(response) {
        if (response == 'true') { this.correctResponseFeedback(); }
        else { this.incorrectResponseFeedback(response); }
      })
      .catch(W.TimeoutError, unresolvedResponseFeedback)
      .catch(function(error) { this.incorrectResponseFeedback(error); });
  },
  // other functions, etc.
}
```

For the record, here is a full list of the code qualities discussed above:

Negative qualities (Robert Martin):  
- Rigidity - parts are all attached; one change prompts many others  
- Fragility - change one thing, unpredictable breaks  
- Immobility - code hopelessly intertangled; reuse through duplication  
- Viscosity - behaving badly is the most attractive option  

Positive qualities (POODR):  
- Transparent - see what will happen when you make a change  
- Reasonable - cost of making a change is proportional to its value  
- Usable - if you wrote it, you can use it in an unexpected context  
- Exemplary - more like it is good; model for new hires  

### 2. Managing dependencies is more important than keeping code DRY

novice error:  
it's ok to be not DRY  
- easier to fix duplication than fix bad abstraction  
- novices look for duplication first, because that's all they know how to recognize  
- TDD and DRY are training wheels  

Example:
`insertResponseMessage` single function  
refactored into 2 separate functions: `displayCorrectResponseMessage` and `displayIncorrectResponseMessage`  

### 3. Reduce the cost of changing your code

Write code that tolerates change.  
- work today once  
- be changeable forever  
- reduce cost of change  

Example:  
Took a whole afternoon of pairing to clean up 2 js files.  
Took 2 days to add one new assertion method.  

![Poodr Rules]({{ site.baseurl }}/assets/poodr.gif "Poodr Rules")

### More resources:  
1. [SandiMetz.com](http://www.sandimetz.com/)  
2. [Sandi Metz presenter page on Confreak](http://confreaks.tv/presenters/sandi-metz?page=)
