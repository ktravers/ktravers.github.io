---
layout: post
title: Geocoder Dos and Do Nots
---

I was working on a Rails project recently where we needed to 1) track the location of bands on tour and 2) give fans a way to see which of their favorite bands were playing near them on any given night. Perfect use case for the [Ruby `geocoder` gem](https://github.com/alexreisner/geocoder), right?

This gem is a long-lived fan favorite in the Ruby community, first [released in 2009](https://github.com/alexreisner/geocoder/releases?after=0.8.7) and [used by upwards of 23.5k projects](https://github.com/alexreisner/geocoder/network/dependents?package_id=UGFja2FnZS02MjgyNQ%3D%3D). However, this was my first time working with it, and I managed to bungle my first implementation. I wanted to share my journey from sad path to happy path, in hopes that it'll help someone else out there, too.

## Setup

We'll use a simplified version of the schema for this story. Our Rails app has `Band`, `Rating`, and `User` models. `Rating` belongs to `User` and `Band`, and both `User` and `Band` have many ratings. We also have a validation in place to enforce that users can only rate a band once.

```ruby
# app/models/band.rb
class Band < ActiveRecord::Base
  has_many :ratings
end

# app/models/rating.rb
class Rating < ActiveRecord::Base
  belongs_to :band
  belongs_to :user

  validates :user_id, uniqueness: { scope: :band }
end

# app/models/user.rb
class User < ActiveRecord::Base
  has_many :ratings
end

# schema.rb
ActiveRecord::Schema.define(version: 20191008222320) do
  create_table "bands", force: :cascade do |t|
    t.string "name", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  create_table "ratings", force: :cascade do |t|
    t.integer "band_id", null: false
    t.integer "user_id", null: false
    t.integer "score", limit: 1, null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["band_id"], name: "index_ratings_on_band_id"
    t.index ["user_id", "band_id"], name: "index_ratings_on_user_id_and_band_id", unique: true
    t.index ["user_id"], name: "index_ratings_on_user_id"
  end

  create_table "users", force: :cascade do |t|
    t.string "email", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end
```

## What Didn't Work 🙅‍♀️

For my first pass, I opted to create a separate `locations` table to 


  - Separate `locations` table associated to my model
  - lat and long lived on locations table, not my model

```ruby
# app/models/location.rb
class Location < ActiveRecord::Base
  belongs_to :band
end

# app/models/band.rb
class Band < ActiveRecord::Base
  has_many :locations
  has_many :ratings

  geocoded_by :location
  after_validation :geocode

  def location
    return nil if locations.empty?
    most_recent = locations.order(created_at: :desc).select(:latitude, :longitude).first

    [most_recent.latitude, most_recent.longitude]
  end

  def set_location(latitude:, longitude:)
    locations.create(latitude: latitude, longitude: longitude)
  end
end

# schema.rb
ActiveRecord::Schema.define(version: 20191008351012) do
  create_table "bands", force: :cascade do |t|
    t.string "name", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  ##
  # NOTE: latitude and longitude fields live on locations table, not bands,
  # the thing we're actually trying to geocode (aka first code design smell)
  create_table "locations", force: :cascade do |t|
    t.integer "band_id", null: false
    t.decimal "latitude", precision: 10, scale: 6, null: false
    t.decimal "longitude", precision: 10, scale: 6, null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["band_id"], name: "index_locations_on_band_id"
  end

  create_table "ratings", force: :cascade do |t|
    # same as above
  end

  create_table "users", force: :cascade do |t|
    # same as above
  end
end
```


## What Worked 🏄‍♀️


  - lat and long fields on my model
  - stubbed address method that returns nil
  - when serializing model, `try(:distance)` for distance (not always available)


```ruby
# app/models/band.rb
class Band < ActiveRecord::Base
  has_many :ratings

  geocoded_by :location
  after_validation :geocode

  def location
    [latitude, longitude]
  end

  def set_location(latitude:, longitude:)
    update(latitude: latitude, longitude: longitude)
  end
end

# schema.rb
ActiveRecord::Schema.define(version: 20191008351012) do
  create_table "bands", force: :cascade do |t|
    t.string "name", null: false
    t.decimal "latitude", precision: 10, scale: 6, null: false
    t.decimal "longitude", precision: 10, scale: 6, null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

  create_table "ratings", force: :cascade do |t|
    # same as above
  end

  create_table "users", force: :cascade do |t|
    # same as above
  end
end
```


## References

- [Geocoder gem site](http://www.rubygeocoder.com/)
- [Geocoder gem source code](https://github.com/alexreisner/geocoder)




################################## SCRATCH

```ruby
irb(main):001:0> band = Band.first
  Band Load (0.1ms)  SELECT  "bands".* FROM "bands" ORDER BY "bands"."id" ASC LIMIT ?  [["LIMIT", 1]]
=> #<Band id: 1, name: "The chairman", created_at: "2019-10-10 04:10:58", updated_at: "2019-10-10 04:10:58">
irb(main):002:0> band.location
  Location Exists (0.2ms)  SELECT  1 AS one FROM "locations" WHERE "locations"."band_id" = ? LIMIT ?  [["band_id", 1], ["LIMIT", 1]]
=> nil
irb(main):003:0> band.geocode
  Location Exists (1.7ms)  SELECT  1 AS one FROM "locations" WHERE "locations"."band_id" = ? LIMIT ?  [["band_id", 1], ["LIMIT", 1]]
=> nil
irb(main):004:0> band.set_location(latitude: 37.782267, longitude: -122.391248)
   (0.2ms)  begin transaction
  SQL (2.9ms)  INSERT INTO "locations" ("band_id", "latitude", "longitude", "created_at", "updated_at") VALUES (?, ?, ?, ?, ?)  [["band_id", 1], ["latitude", 37.782267], ["longitude", -122.391248], ["created_at", "2019-10-10 04:12:12.953575"], ["updated_at", "2019-10-10 04:12:12.953575"]]
   (5.5ms)  commit transaction
=> #<Location id: 1, band_id: 1, latitude: 0.37782267e2, longitude: -0.122391248e3, created_at: "2019-10-10 04:12:12", updated_at: "2019-10-10 04:12:12">
irb(main):005:0> band.location
  Location Load (1.3ms)  SELECT  "locations"."latitude", "locations"."longitude" FROM "locations" WHERE "locations"."band_id" = ? ORDER BY "locations"."created_at" DESC LIMIT ?  [["band_id", 1], ["LIMIT", 1]]
=> [37.782267, -122.391248]
irb(main):006:0> band.geocode
  Location Load (0.5ms)  SELECT  "locations"."latitude", "locations"."longitude" FROM "locations" WHERE "locations"."band_id" = ? ORDER BY "locations"."created_at" DESC LIMIT ?  [["band_id", 1], ["LIMIT", 1]]
Traceback (most recent call last):
        1: from (irb):6
NoMethodError (undefined method `latitude=' for #<Band:0x00007ff3c2b58098>)
```
