---
layout: post
title: Geocoder Dos and Do Nots
---

I was working on a Rails project recently where we needed to 1) track the location of fine art delivery trucks and 2) give dispatchers visibility into which trucks were closest to a given location (in case we need to add an impromptu pickup or drop-off, for example). Perfect use case for the [Ruby `geocoder` gem](https://github.com/alexreisner/geocoder), right?

This gem is a long-respected fan favorite in the Ruby community, first [released in 2009](https://github.com/alexreisner/geocoder/releases?after=0.8.7) and [used by upwards of 23.5k projects](https://github.com/alexreisner/geocoder/network/dependents?package_id=UGFja2FnZS02MjgyNQ%3D%3D). However, this was my first time working with it, and I managed to bungle my first implementation. I wanted to share my journey from sad path to happy path, in hopes that it'll help someone else out there, too.

## Setup

We're starting with the following schema:

```ruby
# app/models/truck.rb
class Truck < ActiveRecord::Base
  def location
    # TODO
  end

  def set_location
    # TODO
  end
end

# schema.rb
ActiveRecord::Schema.define(version: 20191008222320) do
  create_table "trucks", force: :cascade do |t|
    t.string "name", null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end
```

## What Didn't Work üôÖ‚Äç‚ôÄÔ∏è

For my first pass, I opted to create a separate `locations` table. The idea was to maintain separation of concerns between `trucks` and `locations`, keeping them loosely coupled so they'd both be easier to extend (or deprecate, in case this whole truck tracking idea didn't work out).

I also didn't originally like the idea of tacking `latitude` and `longitude` on to the existing `trucks` table. Those didn't seem like inherit properties of a truck; instead, a truck has many locations, current and past. Adding this separate table also allows us to keep track of a truck's past locations, which also seemed appealing to me (in case we wanted to recreate a timeline of the truck's positions, for example).

So with that rationale in mind, I added a `locations` table, model, and associations:

```ruby
# app/models/location.rb
class Location < ActiveRecord::Base
  belongs_to :truck
end

# app/models/truck.rb
class Truck < ActiveRecord::Base
  has_many :locations

  def address
    # TODO
  end

  def location
    return nil if locations.empty?
    most_recent_location = locations.order(created_at: :desc).first

    [most_recent_location.latitude, most_recent_location.longitude]
  end

  def set_location(latitude:, longitude:)
    locations.create(latitude: latitude, longitude: longitude)
  end
end

# schema.rb
ActiveRecord::Schema.define(version: 20191008351012) do
  create_table "trucks", force: :cascade do |t|
    # same as above
  end

  create_table "locations", force: :cascade do |t|
    t.integer "truck_id", null: false
    t.decimal "latitude", precision: 10, scale: 6, null: false
    t.decimal "longitude", precision: 10, scale: 6, null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
    t.index ["truck_id"], name: "index_locations_on_truck_id"
  end
end
```

Next, I checked the [geocode docs](https://github.com/alexreisner/geocoder#geocoding-objects) and saw there's three things necessary to Geocode an object:

1. Provide a method that returns an address to geocode

I'd read somewhere it was ok to stub this out to return nil, so I opted to start there, since knowing a truck's address wasn't one of our requirements.

2. Provide a way to store latitude and longitude coordinates.

The docs suggest adding `:latitude` and `:longitude` attributes to the model you're geocoding (in our case, `Truck`), but I figured I could overwrite these by adding methods that hooked into the associated `Location` attributes instead.

3. Add `geocoded_by` and `after_validation :geocode` to model

I opted to use the default examples provided in the docs.

...all of which lead to the following updates to my `Truck` model:


```ruby
# app/models/truck.rb
class Truck < ActiveRecord::Base
  has_many :locations

  geocoded_by :address
  after_validation :geocode

  def address
    nil # stubbed, not necessary for our requirements
  end

  def latitude
    location.try(:latitude)
  end

  def longitude
    location.try(:longitude)
  end

  def location
    return nil if locations.empty?
    locations.order(created_at: :desc).first
  end

  def set_location(latitude:, longitude:)
    locations.create(latitude: latitude, longitude: longitude)
  end
end
```

This configuration worked fine in terms of setting and getting location:

```ruby
irb(main):001:0> truck = Truck.first
  Truck Load (0.1ms)  SELECT  "trucks".* FROM "trucks" ORDER BY "trucks"."id" ASC LIMIT ?  [["LIMIT", 1]]
=> #<Truck id: 1, name: "The chairman", created_at: "2019-10-10 04:10:58", updated_at: "2019-10-10 04:10:58">
irb(main):002:0> truck.location
  Location Exists (0.2ms)  SELECT  1 AS one FROM "locations" WHERE "locations"."truck_id" = ? LIMIT ?  [["truck_id", 1], ["LIMIT", 1]]
=> nil
irb(main):003:0> truck.set_location(latitude: 37.782267, longitude: -122.391248)
   (0.2ms)  begin transaction
  SQL (2.9ms)  INSERT INTO "locations" ("truck_id", "latitude", "longitude", "created_at", "updated_at") VALUES (?, ?, ?, ?, ?)  [["truck_id", 1], ["latitude", 37.782267], ["longitude", -122.391248], ["created_at", "2019-10-10 04:12:12.953575"], ["updated_at", "2019-10-10 04:12:12.953575"]]
   (5.5ms)  commit transaction
=> #<Location id: 1, truck_id: 1, latitude: 0.37782267e2, longitude: -0.122391248e3, created_at: "2019-10-10 04:12:12", updated_at: "2019-10-10 04:12:12">
irb(main):004:0> truck.location
  Location Load (1.3ms)  SELECT  "locations"."latitude", "locations"."longitude" FROM "locations" WHERE "locations"."truck_id" = ? ORDER BY "locations"."created_at" DESC LIMIT ?  [["truck_id", 1], ["LIMIT", 1]]
=> #<Location id: 1, truck_id: 1, latitude: 0.37782267e2, longitude: -0.122391248e3, created_at: "2019-10-10 04:12:12", updated_at: "2019-10-10 04:12:12">
```

However, it broke down immediately when I tried to actually geocode anything:

```ruby
irb(main):005:0> truck.geocode
  Location Load (0.5ms)  SELECT  "locations"."latitude", "locations"."longitude" FROM "locations" WHERE "locations"."truck_id" = ? ORDER BY "locations"."created_at" DESC LIMIT ?  [["truck_id", 1], ["LIMIT", 1]]
Traceback (most recent call last):
        1: from (irb):5
NoMethodError (undefined method `latitude=' for #<Truck:0x00007ff3c2b58098>)
```

There's not really a good workaround for this error. Adding setter methods for `Truck#latitude=` and `Truck#longitude=` doesn't do the trick, because we don't want to create new `Location` records with only one of those attributes filled in. I thought about adding some kind of temp `Location` object that'd be persisted after both attributes were filled in, but at that point, the code smell was pretty obvious. It shouldn't be this difficult. I was clearly doing something wrong.

![Gob Bluth has made a huge mistake](http://tworunningsisters.files.wordpress.com/2014/05/gob-bluth.jpg "Gob Bluth has made a huge mistake")


## What Worked üèÑ‚Äç‚ôÄÔ∏è




  - lat and long fields on my model
  - stubbed address method that returns nil
  - when serializing model, `try(:distance)` for distance (not always available)


```ruby
# app/models/truck.rb
class Truck < ActiveRecord::Base
  geocoded_by :address
  after_validation :geocode

  def address
    nil # stubbed, not necessary for our requirements
  end

  def distance
    try(:distance) # available if object has been geocoded
  end

  def location
    [latitude, longitude]
  end

  def set_location(latitude:, longitude:)
    update(latitude: latitude, longitude: longitude)
  end
end

# schema.rb
ActiveRecord::Schema.define(version: 20191008351012) do
  create_table "trucks", force: :cascade do |t|
    t.string "name", null: false
    t.decimal "latitude", precision: 10, scale: 6, null: false
    t.decimal "longitude", precision: 10, scale: 6, null: false
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
end
```


## References

- [Geocoder gem site](http://www.rubygeocoder.com/)
- [Geocoder gem source code](https://github.com/alexreisner/geocoder)




################################## SCRATCH

```ruby
irb(main):001:0> truck = Truck.first
  Truck Load (0.1ms)  SELECT  "trucks".* FROM "trucks" ORDER BY "trucks"."id" ASC LIMIT ?  [["LIMIT", 1]]
=> #<Truck id: 1, name: "The chairman", created_at: "2019-10-10 04:10:58", updated_at: "2019-10-10 04:10:58">
irb(main):002:0> truck.location
  Location Exists (0.2ms)  SELECT  1 AS one FROM "locations" WHERE "locations"."truck_id" = ? LIMIT ?  [["truck_id", 1], ["LIMIT", 1]]
=> nil
irb(main):003:0> truck.geocode
  Location Exists (1.7ms)  SELECT  1 AS one FROM "locations" WHERE "locations"."truck_id" = ? LIMIT ?  [["truck_id", 1], ["LIMIT", 1]]
=> nil
irb(main):004:0> truck.set_location(latitude: 37.782267, longitude: -122.391248)
   (0.2ms)  begin transaction
  SQL (2.9ms)  INSERT INTO "locations" ("truck_id", "latitude", "longitude", "created_at", "updated_at") VALUES (?, ?, ?, ?, ?)  [["truck_id", 1], ["latitude", 37.782267], ["longitude", -122.391248], ["created_at", "2019-10-10 04:12:12.953575"], ["updated_at", "2019-10-10 04:12:12.953575"]]
   (5.5ms)  commit transaction
=> #<Location id: 1, truck_id: 1, latitude: 0.37782267e2, longitude: -0.122391248e3, created_at: "2019-10-10 04:12:12", updated_at: "2019-10-10 04:12:12">
irb(main):005:0> truck.location
  Location Load (1.3ms)  SELECT  "locations"."latitude", "locations"."longitude" FROM "locations" WHERE "locations"."truck_id" = ? ORDER BY "locations"."created_at" DESC LIMIT ?  [["truck_id", 1], ["LIMIT", 1]]
=> [37.782267, -122.391248]
irb(main):006:0> truck.geocode
  Location Load (0.5ms)  SELECT  "locations"."latitude", "locations"."longitude" FROM "locations" WHERE "locations"."truck_id" = ? ORDER BY "locations"."created_at" DESC LIMIT ?  [["truck_id", 1], ["LIMIT", 1]]
Traceback (most recent call last):
        1: from (irb):6
NoMethodError (undefined method `latitude=' for #<Truck:0x00007ff3c2b58098>)
```
